/*
 * Wire
 * Copyright (C) 2016 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package com.waz.model

import android.database.Cursor
import android.database.DatabaseUtils.queryNumEntries
import android.database.sqlite.SQLiteDatabase
import com.waz.api.Message
import com.waz.api.Message.Type._
import com.waz.db.Col._
import com.waz.db.Dao
import com.waz.model.ConversationData.ConversationDataDao
import com.waz.model.MessageData.MessageState
import com.waz.model.messages.media.{MediaAssetData, MediaAssetDataProtocol}
import com.waz.service.conversation.ConversationsService
import com.waz.service.media.RichMediaContentParser
import com.waz.utils.{EnumCodec, JsonDecoder, JsonEncoder}
import org.json.JSONObject
import org.threeten.bp.Instant

import scala.collection.breakOut

case class MessageData(id: MessageId,
                       convId: ConvId,
                       source: EventId,
                       edit: EventId,
                       msgType: Message.Type,
                       userId: UserId,
                       content: Seq[MessageContent] = Vector.empty,
                       hotKnock: Boolean = false,
                       firstMessage: Boolean = false,
                       otr: Boolean = false,
                       members: Set[UserId] = Set.empty[UserId],
                       recipient: Option[UserId] = None,
                       email: Option[String] = None,
                       name: Option[String] = None,
                       state: MessageState = Message.Status.SENT,
                       time: Instant = Instant.now,
                       localTime: Instant = MessageData.UnknownInstant) {

  def getContent(index: Int) = {
    if (index == 0) content.headOption.getOrElse(MessageContent.Empty)
    else content.drop(index).headOption.getOrElse(MessageContent.Empty)
  }

  def contentString = content.map(_.content).mkString(" ")

  /**
   * Returns first message content assetId. Only makes sense for ASSET messages.
   */
  def assetId = content.headOption.flatMap(_.asset)

  def isLocal = state == Message.Status.DEFAULT || state == Message.Status.PENDING || state == Message.Status.FAILED || state == Message.Status.FAILED_READ

  /**
   * System messages are messages generated by backend in response to user actions.
   * Those messages are not encrypted and don't have global message id (nonce).
   *
   */
  def isSystemMessage = msgType match {
    case RENAME | CONNECT_REQUEST | CONNECT_ACCEPTED | MEMBER_JOIN | MEMBER_LEAVE | MISSED_CALL | INCOMING_CALL => true
    case _ => false
  }

  def hasSameContentType(m: MessageData) =
    msgType == m.msgType && content.zip(m.content).forall { case (c, c1) => c.tpe == c1.tpe }
}

case class MessageContent(tpe: Message.Part.Type, content: String, richMedia: Option[MediaAssetData], asset: Option[AssetId], width: Int, height: Int, syncNeeded: Boolean, mentions: Map[UserId, String])

object MessageContent extends ((Message.Part.Type, String, Option[MediaAssetData], Option[AssetId], Int, Int, Boolean, Map[UserId, String]) => MessageContent) {
  import MediaAssetDataProtocol._

  val Empty = apply(Message.Part.Type.TEXT, "")

  def apply(tpe: Message.Part.Type, content: String, asset: Option[AssetId] = None, width: Int = 0, height: Int = 0, syncNeeded: Boolean = false, mentions: Map[UserId, String] = Map.empty): MessageContent =
    MessageContent(tpe, content, if (tpe == Message.Part.Type.SPOTIFY || tpe == Message.Part.Type.SOUNDCLOUD || tpe == Message.Part.Type.YOUTUBE) Some(MediaAssetData.empty(tpe)) else None, asset, width, height, syncNeeded, mentions)

  implicit lazy val Decoder: JsonDecoder[MessageContent] = new JsonDecoder[MessageContent] {
    import com.waz.utils.JsonDecoder._

    import scala.collection.JavaConverters._

    def mentionsMap(js: JSONObject): Map[UserId, String] =
      js.keys().asInstanceOf[java.util.Iterator[String]].asScala.map(key => UserId(key) -> js.getString(key)).toMap

    override def apply(implicit js: JSONObject): MessageContent = {
      val tpe = ContentTypeCodec.decode('type)
      val mentions = if (js.has("mentions") && !js.isNull("mentions")) mentionsMap(js.getJSONObject("mentions")) else Map.empty[UserId, String]
      val richMedia = opt[MediaAssetData]('richMedia) orElse { // if there's no media asset for rich media message contents, we create an expired empty one
        if (tpe == Message.Part.Type.SPOTIFY || tpe == Message.Part.Type.SOUNDCLOUD || tpe == Message.Part.Type.YOUTUBE) Some(MediaAssetData.empty(tpe)) else None
      }

      MessageContent(tpe, 'content, richMedia, decodeOptId[AssetId]('asset), 'width, 'height, 'syncNeeded, mentions)
    }
  }

  implicit lazy val Encoder: JsonEncoder[MessageContent] = new JsonEncoder[MessageContent] {
    override def apply(v: MessageContent): JSONObject = JsonEncoder { o =>
      o.put("type", ContentTypeCodec.encode(v.tpe))
      if (v.content != "") o.put("content", v.content)
      v.richMedia foreach (m => o.put("richMedia", MediaAssetEncoder(m)))
      v.asset.foreach { id => o.put("asset", id.str) }
      if (v.width != 0) o.put("width", v.width)
      if (v.height != 0) o.put("height", v.height)
      if (v.syncNeeded) o.put("syncNeeded", v.syncNeeded)
      if (v.mentions.nonEmpty) o.put("mentions", JsonEncoder { o =>
        v.mentions foreach { case (user, name) => o.put(user.str, name) }
      })
    }
  }

  implicit lazy val ContentTypeCodec: EnumCodec[Message.Part.Type, String] = EnumCodec.injective {
    case Message.Part.Type.TEXT => "Text"
    case Message.Part.Type.ASSET => "Asset"
    case Message.Part.Type.YOUTUBE => "YouTube"
    case Message.Part.Type.SOUNDCLOUD => "SoundCloud"
    case Message.Part.Type.SPOTIFY => "Spotify"
    case Message.Part.Type.TWITTER => "Twitter"
    case Message.Part.Type.WEB_LINK => "WebLink"
    case Message.Part.Type.GOOGLE_MAPS => "GoogleMaps"
  }
}

object MessageData extends ((MessageId, ConvId, EventId, EventId, Message.Type, UserId, Seq[MessageContent], Boolean, Boolean, Boolean, Set[UserId], Option[UserId], Option[String], Option[String], Message.Status, Instant, Instant) => MessageData) {
  val Empty = new MessageData(MessageId(""), ConvId(""), EventId.Zero, EventId.Zero, Message.Type.TEXT, UserId(""))
  val UnknownInstant = Instant.EPOCH

  type MessageState = Message.Status

  implicit lazy val Decoder: JsonDecoder[MessageData] = new JsonDecoder[MessageData] {
    import JsonDecoder._
    override def apply(implicit js: JSONObject): MessageData =
      MessageData('id,
        decodeId[ConvId]('convId),
        'source,
        'edit,
        MessageTypeCodec.decode('msgType),
        'userId,
        decodeSeq[MessageContent]('content),
        'hotKnock,
        'firstMessage,
        'otr,
        JsonDecoder.array('members)((arr, i) => UserId(arr.getString(i))).toSet,
        decodeOptId[UserId]('recipient),
        'email,
        'name,
        Message.Status.valueOf('state),
        Instant.ofEpochMilli(decodeLong('time)),
        Instant.ofEpochMilli(decodeLong('localTime)))
  }

  implicit lazy val Encoder: JsonEncoder[MessageData] = new JsonEncoder[MessageData] {
    override def apply(v: MessageData): JSONObject = JsonEncoder { o =>
      o.put("id", v.id.str)
      o.put("convId", v.convId.str)
      o.put("source", v.source.str)
      o.put("edit", v.edit.str)
      o.put("msgType", MessageTypeCodec.encode(v.msgType))
      o.put("userId", v.userId.str)
      o.put("content", JsonEncoder.arr(v.content))
      o.put("hotKnock", v.hotKnock)
      o.put("otr", v.otr)
      o.put("firstMessage", v.firstMessage)
      o.put("members", JsonEncoder.arrString(v.members.toSeq.map(_.str)))
      v.recipient foreach { r => o.put("recipient", r.str) }
      v.email foreach { o.put("email", _) }
      v.name foreach { o.put("name", _) }
      o.put("state", v.state.name())
      o.put("time", v.time.toEpochMilli)
      o.put("localTime", v.localTime.toEpochMilli)
    }
  }
  
  implicit lazy val MessageTypeCodec: EnumCodec[Message.Type, String] = EnumCodec.injective {
    case Message.Type.TEXT => "Text"
    case Message.Type.ASSET => "Asset"
    case Message.Type.KNOCK => "Knock"
    case Message.Type.MEMBER_JOIN => "MemberJoin"
    case Message.Type.MEMBER_LEAVE => "MemberLeave"
    case Message.Type.CONNECT_REQUEST => "ConnectRequest"
    case Message.Type.CONNECT_ACCEPTED => "ConnectAccepted"
    case Message.Type.RENAME => "Rename"
    case Message.Type.MISSED_CALL => "MissedCall"
    case Message.Type.INCOMING_CALL => "IncomingCall"
    case Message.Type.RICH_MEDIA => "RichMedia"
    case Message.Type.OTR_ERROR => "OtrFailed"
    case Message.Type.OTR_VERIFIED => "OtrVerified"
    case Message.Type.OTR_UNVERIFIED => "OtrUnverified"
    case Message.Type.OTR_DEVICE_ADDED => "OtrDeviceAdded"
    case Message.Type.STARTED_USING_DEVICE => "StartedUsingDevice"
    case Message.Type.HISTORY_LOST => "HistoryLost"
    case Message.Type.UNKNOWN => "Unknown"
  }

  implicit object MessageDataDao extends Dao[MessageData, MessageId]  {
    import com.waz.db._

    val Id = id[MessageId]('_id, "PRIMARY KEY").apply(_.id)
    val Conv = id[ConvId]('conv_id).apply(_.convId)
    val SourceSeq = long('source_seq)(_.source.sequence)
    val SourceHex = text('source_hex)(_.source.hex)
    val Edit = eid('edit)(_.edit)
    val Type = text[Message.Type]('msg_type, MessageTypeCodec.encode, MessageTypeCodec.decode)(_.msgType)
    val User = id[UserId]('user_id).apply(_.userId)
    val Content = jsonArray[MessageContent, Seq, Vector]('content).apply(_.content)
    val ContentSize = int('content_size)(_.content.size)
    val HotKnock = bool('hot)(_.hotKnock)
    val FirstMessage = bool('first_msg)(_.firstMessage)
    val Otr = bool('otr)(_.otr)
    val Members = set[UserId]('members, _.mkString(","), _.split(",").filter(!_.isEmpty).map(UserId(_))(breakOut))(_.members)
    val Recipient = opt(id[UserId]('recipient))(_.recipient)
    val Email = opt(text('email))(_.email)
    val Name = opt(text('name))(_.name)
    val State = text[MessageState]('msg_state, _.name, Message.Status.valueOf)(_.state)
    val Time = timestamp('time)(_.time)
    val LocalTime = timestamp('local_time)(_.localTime)

    override val idCol = Id

    override val table = Table("Messages", Id, Conv, SourceSeq, SourceHex, Edit, Type, User, Content, Time, LocalTime, HotKnock, FirstMessage, Otr, Members, Recipient, Email, Name, State, ContentSize)

    override def onCreate(db: SQLiteDatabase): Unit = {
      super.onCreate(db)
      db.execSQL(s"CREATE INDEX IF NOT EXISTS Messages_conv_source_idx on Messages ( conv_id, source_seq, source_hex )")
      db.execSQL(s"CREATE INDEX IF NOT EXISTS Messages_conv_time_source_idx on Messages ( conv_id, time, source_seq, source_hex )")
    }

    override def apply(implicit cursor: Cursor): MessageData =
      MessageData(Id, Conv, new EventId(SourceSeq, SourceHex), Edit, Type, User, Content, HotKnock, FirstMessage, Otr, Members, Recipient, Email, Name, State, Time, LocalTime)

    def deleteForConv(id: ConvId)(implicit db: SQLiteDatabase) = delete(Conv, id)

    def deleteUpTo(id: ConvId, upTo: Instant)(implicit db: SQLiteDatabase) = db.delete(table.name, s"${Conv.name} = '${id.str}' AND ${Time.name} <= ${Time(upTo)}", null)

    def first(conv: ConvId)(implicit db: SQLiteDatabase) = single(db.query(table.name, null, s"${Conv.name} = '$conv'", null, null, null, s"${Time.name} ASC, ${SourceSeq.name} ASC, ${SourceHex.name} ASC", "1"))

    def last(conv: ConvId)(implicit db: SQLiteDatabase) = single(db.query(table.name, null, s"${Conv.name} = '$conv'", null, null, null, s"${Time.name} DESC, ${SourceSeq.name} DESC, ${SourceHex.name} DESC", "1"))

    def lastSent(conv: ConvId)(implicit db: SQLiteDatabase) = single(db.query(table.name, null, s"${Conv.name} = '$conv' AND ${State.name} = '${Message.Status.SENT.name}'", null, null, null, s"${Time.name} DESC, ${SourceSeq.name} DESC, ${SourceHex.name} DESC", "1"))

    def lastIncomingKnock(convId: ConvId, selfUser: UserId)(implicit db: SQLiteDatabase): Option[MessageData] = single(
      db.query(table.name, null, s"${Conv.name} = ? AND ${Type.name} = ? AND ${User.name} <> ?", Array(convId.toString, Type(Message.Type.KNOCK), selfUser.str), null, null, s"${SourceSeq.name} DESC, ${SourceHex.name} DESC", "1")
    )

    def lastMissedCall(convId: ConvId)(implicit db: SQLiteDatabase): Option[MessageData] = single(
      db.query(table.name, null, s"${Conv.name} = ? AND ${Type.name} = ?", Array(convId.toString, Type(Message.Type.MISSED_CALL)), null, null, s"${SourceSeq.name} DESC, ${SourceHex.name} DESC", "1")
    )

    private val MessageEntryColumns = Array(Id.name, User.name, Type.name, State.name, ContentSize.name)
    private val MessageEntryReader = new Reader[MessageEntry] {
      override def apply(implicit c: Cursor): MessageEntry = MessageEntry(Id, User, Type, State, ContentSize)
    }

    def countMessages(convId: ConvId, p: MessageEntry => Boolean)(implicit db: SQLiteDatabase): Int =
      iteratingWithReader(MessageEntryReader)(db.query(table.name, MessageEntryColumns, s"${Conv.name} = ?", Array(convId.toString), null, null, null)).acquire(_ count p)

    def findMessages(convId: ConvId, event: Seq[EventId])(implicit db: SQLiteDatabase) = {
      val eventsSet = event.toSet
      iterating(db.query(table.name, null, s"${Conv.name} = '${convId.str}' AND ${SourceSeq.name} IN (${event.map(_.sequence).mkString(",")})", null, null, null, null)).map(_ filter (m => eventsSet(m.source) ))
    }

    def countNewer(convId: ConvId, time: Instant)(implicit db: SQLiteDatabase) =
      queryNumEntries(db, table.name, s"${Conv.name} = '${convId.str}' AND ${Time.name} > ${time.toEpochMilli}")

    def countFailed(convId: ConvId)(implicit db: SQLiteDatabase) = queryNumEntries(db, table.name, s"${Conv.name} = '${convId.str}' AND ${State.name} = '${Message.Status.FAILED}'")

    def listLocalMessages(convId: ConvId)(implicit db: SQLiteDatabase) = list(db.query(table.name, null, s"${Conv.name} = '$convId' AND ${State.name} in ('${Message.Status.DEFAULT}', '${Message.Status.PENDING}', '${Message.Status.FAILED}')", null, null, null, s"${Time.name} ASC"))

    def findLocalFrom(convId: ConvId, time: Instant)(implicit db: SQLiteDatabase) =
      iterating(db.query(table.name, null, s"${Conv.name} = '$convId' AND ${State.name} in ('${Message.Status.DEFAULT}', '${Message.Status.PENDING}', '${Message.Status.FAILED}') AND ${Time.name} >= ${time.toEpochMilli}", null, null, null, s"${Time.name} ASC"))

    def findLatestUpToEvent(convId: ConvId, event: EventId)(implicit db: SQLiteDatabase) =
      single(db.query(table.name, null, s"${Conv.name} = '$convId' AND (${SourceSeq.name} < ${event.sequence} OR ${SourceSeq.name} = ${event.sequence} AND ${SourceHex.name} <= '${event.hex}')", null, null, null, s"${SourceSeq.name} DESC ,${SourceHex.name} DESC", "1"))

    def findMessages(conv: ConvId)(implicit db: SQLiteDatabase) = db.query(table.name, null, s"${Conv.name} = '$conv'", null, null, null, s"${Time.name} ASC, ${SourceSeq.name} ASC, ${SourceHex.name} ASC")

    def findMessagesFrom(conv: ConvId, time: Instant)(implicit db: SQLiteDatabase) =
      iterating(db.query(table.name, null, s"${Conv.name} = '$conv' and ${Time.name} >= ${time.toEpochMilli}", null, null, null, s"${Time.name} ASC, ${SourceSeq.name} ASC, ${SourceHex.name} ASC"))

    private val IndexColumns = Array(Id.name, Time.name, SourceSeq.name, SourceHex.name)
    def msgIndexCursor(conv: ConvId)(implicit db: SQLiteDatabase) = db.query(table.name, IndexColumns, s"${Conv.name} = '$conv'", null, null, null, s"${Time.name} ASC, ${SourceSeq.name} ASC, ${SourceHex.name} ASC")

    def countAtLeastAsOld(conv: ConvId, time: Instant)(implicit db: SQLiteDatabase) =
      queryNumEntries(db, table.name, s"""${Conv.name} = '${Conv(conv)}' AND ${Time.name} <= ${Time(time)}""")

    def countSentByType(selfUserId: UserId, tpe: Message.Type)(implicit db: SQLiteDatabase) = queryNumEntries(db, table.name, s"${User.name} = '${User(selfUserId)}' AND ${Type.name} = '${Type(tpe)}'")

    /**
     * Returns incoming messages (for all unmuted conversations) with local time greater then given time in millis.
     */
    def listIncomingMessages(selfUserId: UserId, since: Long = System.currentTimeMillis() - ConversationsService.KnockTimeout.toMillis, limit: Int = 25)(implicit db: SQLiteDatabase): Vector[MessageData] = list(db.rawQuery(
      s"""
         | SELECT msg.*
         | FROM ${table.name} msg, ${ConversationDataDao.table.name} conv
         | WHERE msg.${Conv.name} = conv.${ConversationDataDao.Id.name} AND conv.${ConversationDataDao.Muted.name} = 0
         | AND msg.${LocalTime.name} > ? AND msg.${User.name} != ?
         | ORDER BY msg.${LocalTime.name} DESC
         | LIMIT $limit""".stripMargin, Array(since.toString, selfUserId.str)
    ))
  }

  case class MessageEntry(id: MessageId, user: UserId, tpe: Message.Type = Message.Type.TEXT, state: Message.Status = Message.Status.DEFAULT, contentSize: Int = 1)

  val contentParser = new RichMediaContentParser

  def messageContent(message: String, mentions: Map[UserId, String] = Map.empty): (Message.Type, Seq[MessageContent]) =
    if (message.isEmpty) (Message.Type.TEXT, Seq(MessageContent(Message.Part.Type.TEXT, message, mentions = mentions)))
    else {
      val ct = contentParser.splitContent(message)
      if (ct.size == 1 && ct.head.tpe == Message.Part.Type.TEXT) (Message.Type.TEXT, applyMentions(ct, mentions))
      else (Message.Type.RICH_MEDIA, applyMentions(ct, mentions))
    }

  def textContent(message: String): Seq[MessageContent] = Seq(MessageContent(Message.Part.Type.TEXT, message))

  def imageContent(asset: AssetId, width: Int, height: Int): Seq[MessageContent] = Seq(MessageContent(Message.Part.Type.ASSET, "", Some(asset), width, height))

  private def applyMentions(content: Seq[MessageContent], mentions: Map[UserId, String]) =
    if (mentions.isEmpty) content
    else if (content.size == 1) content.map(_.copy(mentions = mentions))
    else content map { ct =>
      val ms = mentions.filter { case (id, name) => ct.content.contains(s"@$name") }
      if (ms.isEmpty) ct else ct.copy(mentions = ms)
    }
}
